#!/usr/bin/env python3
from typing import Union
import argparse
from newm import cmd
from collections.abc import Sequence


# Declare new commands, in the following format "command": "description"
# See main function
command_without_args: dict[str, str] = {
    "inhibit-idle": "Prevents newm from going into idle states (dimming the screen)",
    "config": "Reloads the configuration",
    "lock": "Locks the screen",
    "clean": "Removes orphaned states, which can happen, but shouldn't (if you encounter the need for this, please file a bug)",
    "debug": "Prints out some debug info on the current state of views",
    "finish-inhibit-idle": "Restore the idle states",
    "close-launcher": "Close launcher",
    "unlock": "Unlocks the screen",
}

# Declare new commands, in the following format:
# "command": {
#   "help": "description",
#   "args": {
#       "arg_name": "description",
#       ...
#   }
# }
# See main function
command_needs_args: dict[str, dict[str, Union[str, dict[str, str]]]] = {
    "open-virtual-output": {
        "help": "opens a new virtual output (see newm-sidecar)",
        "args": {"name": "newm-cmd open-virtual-output <name>"},
    },
    "close-virtual-output": {
        "help": "close a virtual output",
        "args": {"name": "newm-cmd close-virtual-output <name>"},
    },
}


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="command", required=True)

    for command, help in command_without_args.items():
        subparsers.add_parser(command, help=help)

    for command, meta in command_needs_args.items():
        command_parser = subparsers.add_parser(command, help=meta["help"])
        for argument, help in meta["args"].items():
            command_parser.add_argument(argument, help=help)

    args = parser.parse_args(argv)

    if args.command in command_without_args.keys():
        return call_without_args(args.command)
    elif args.command in command_needs_args.keys():
        dict_args = vars(args)
        # dict_args[a] for a in command_needs_args[args.command]["args"].keys()
        call_with_args(
            args.command,
            *tuple(
                filter(
                    lambda v: v is not None,
                    map(
                        lambda k: dict_args.get(k, None),
                        command_needs_args[args.command]["args"].keys(),
                    ),
                )
            ),
        )
    else:
        raise NotImplementedError(
            f"Command {args.command} does not exist.",
        )


def call_without_args(command: str) -> int:
    cmd(command)
    return 0


def call_with_args(command: str, *args) -> int:
    cmd(command, *args)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
