#!/usr/bin/env python3
from typing import Union
import argparse
from newm import cmd
from collections.abc import Sequence


# Declare new commands, in the following format:
# "command": {
#   "help": "description",
#   "args": {
#       "arg_name": "description",
#       ...
#   }
# }
# See main function
commands: dict[str, dict[str, Union[str, dict[str, str]]]] = {
    "inhibit-idle": {
        "help": "Prevents newm from going into idle states (dimming the screen)",
        "args": {},
    },
    "config": {
        "help": "Reloads the configuration",
        "args": {},
    },
    "lock": {
        "help": "Locks the screen",
        "args": {},
    },
    "clean": {
        "help": "Removes orphaned states, which can happen, but shouldn't (if you encounter the need for this, please file a bug)",
        "args": {},
    },
    "debug": {
        "help": "Prints out some debug info on the current state of views",
        "args": {},
    },
    "unlock": {
        "help": "Unlocks the screen",
        "args": {},
    },
    "open-virtual-output": {
        "help": "opens a new virtual output (see newm-sidecar)",
        "args": {"output_name": "newm-cmd open-virtual-output <name>"},
    },
    "close-virtual-output": {
        "help": "close a virtual output",
        "args": {"output_name": "newm-cmd close-virtual-output <name>"},
    },
}


def main(argv: Sequence[str] | None = None) -> int:
    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers(dest="command", required=True)

    for command, meta in commands.items():
        command_parser = subparsers.add_parser(command, help=meta["help"])
        for argument, help in meta["args"].items():
            command_parser.add_argument(argument, help=help)

    args = parser.parse_args(argv)

    if args.command in commands.keys():
        dict_args = vars(args)
        # dict_args[a] for a in command_needs_args[args.command]["args"].keys()
        call_cmd(
            args.command,
            *tuple(
                filter(
                    lambda v: v is not None,
                    map(
                        lambda k: dict_args.get(k, None),
                        commands[args.command]["args"].keys(),
                    ),
                )
            ),
        )
    else:
        raise NotImplementedError(
            f"Command {args.command} does not exist, see: newm-cmd -h.",
        )


def call_cmd(command: str, *args) -> int:
    cmd(command, *args)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
